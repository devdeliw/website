[{"id":0,"href":"/posts/coral_intro/","title":"What is CORAL?","section":"Writeups","content":" In the past few months I\u0026rsquo;ve become immensely interested in scientific computing and writing fast code. I started CORAL as a project to learn both at the same time. And learn Rust.\nCORAL stands for COre Rust Architecture for Linear algebra. It is an implementation of the Basic Linear Algebra Subprograms, or BLAS, in pure Rust. It is written for AArch64 architectures only.\nBLAS is the set of the most common low-level operations, \u0026ldquo;kernels\u0026rdquo;, for linear algebra. Most numerical routines involve linear algebra; it is clear that a useful BLAS must be as fast as possible. These kernels naturally separate into three levels, each monumentally more difficult than the last.\nLevel 1# Vector-Vector Operations Think of things like calculating the dot product, $\\vec{x} \\cdot \\vec{y}$, or multiplying by a scalar, $\\alpha \\vec{x}$. These operations are memory bound; the bottleneck is how fast memory is moved around, not how fast the CPU is. Good performance can be achieved if code is written intelligently.\nLevel 2# Matrix-Vector Operations Think of things like calculating $A\\vec{x}$, or solving a system of equations $A\\vec{x} = \\vec{b}$ given a triangular matrix $A$ and $\\vec{b}$. These operations are also memory bound. It is here though, that clever tricks leveraging cache to maximize performance begin. Good performance can still be achieved with smart code.\nLevel 3# Matrix-Matrix Operations Think of things like calculating $AB$. It\u0026rsquo;s fair to say $AB$ is the most executed mathematical operation on the planet. It is also compute bound, which means reaching peak performance is still an active area of research.\nA BLAS\u0026rsquo;s performance is almost entirely dependent on how fast it can calculate $AB$. Consequently, solving many $AB$s is how supercomputers are benchmarked today. AI only exists today because matrix multiplication became fast enough.\nOne of BLAS\u0026rsquo;s pioneers is Kazushige Goto, who hand optimized assembly routines for his GotoBLAS. This implementation outperformed many BLAS used at the time and became the backbone for the current industry standard OpenBLAS. If you use Python and NumPy for vector calculations, OpenBLAS is why it\u0026rsquo;s so fast.\nCORAL isn’t built to compete with industry BLAS, but to reach $\\simeq$ 80 % of their performance on AArch64.$^\\dagger$ This is to educate myself and others on how these fast low-level algorithms work. The purpose of this \u0026ldquo;blog\u0026rdquo; is to walk through how to intelligently write code to make a fast BLAS. Just not one that\u0026rsquo;s used by supercomputers.\n$^\\dagger$ Turns out, on AArch64, CORAL is actually comparable to OpenBLAS when both are single-threaded. CORAL outperforms for GEMM, and $\\sim$comparable for SGEMM (single precision general matrix multiplication). This makes sense, since SGEMM is the most used. You can see the benchmark(s) here. However, optimized for Apple Silicon, Apple Accelerate, another BLAS implementation, absolutely wrecks both CORAL and OpenBLAS.\n"},{"id":1,"href":"/posts/nasa_derive_1/","title":"The Spin Hamiltonian","section":"Writeups","content":" This post is math heavy. I\u0026rsquo;ll try to walk through it all elegantly though.\nThe Spin Hamiltonian $\\mathscr{H}$ governs the spin-physics of recombination. It\u0026rsquo;s what we need to program before starting to simulate EDMR.\n$ \\mathscr{H} $ is a combination of the Zeeman Effect, Hyperfine Interactions, the Zero-field Splitting Effect, and the Exchange Interaction.\n$$ \\mathscr{H} = \\hat{H}_{\\mathrm{Z}} + \\hat{H}_{\\mathrm{HF}} + \\hat{H}_{\\mathrm{ZFS}} + \\hat{H}_{\\mathrm{EX}} $$\nNormally $\\mathscr{H}$ also has a \u0026ldquo;Nuclear Quadropole Interaction Hamiltonian\u0026rdquo; as well. But since Silicon Carbide (4H-SiC) has no nuclei with nuclear spin $I \u0026gt; 1/2$, it\u0026rsquo;s set to 0.\nThe goal of this post is to provide a good enough derivation of each Hamiltonian term. Finally, a complete Hamiltonian description is given.\nI use a fancy $\\mathscr{H}$ to represent the full Spin Hamiltonian. Sub-Hamiltonians are normal $H$\u0026rsquo;s but with hats (e.g. $\\hat{H}_Z$).\nThe Zeeman Effect# A spinning charged particle is a magnetic dipole. Its magnetic dipole moment, $\\vec{\\mu}$, is proportional to its spin angular momentum, $\\vec{S}$\n$$ \\vec{\\mu} = \\gamma \\vec{S}.$$\nThe proportionality constant, $\\gamma$ is the gyromagnetic ratio. From the Dirac equation it can be shown\n$$ \\vec{\\mu} = \\gamma \\vec{S} = -g \\frac{q}{2m_e} \\vec{S} = -\\frac{g\\mu_B}{\\hbar} \\vec{S}, $$\nwhere $g \\approx 2.0023$ is the Landé $g$-factor for the free electron and $\\mu_B \\approx 9.2 \\cdot 10^{-24} J/T $ is the Bohr Magneton.\nWhen a magnetic dipole is placed in a magnetic field $\\vec{B}$, it experiences a torque, $\\vec{\\mu} \\times \\vec{B}$, which tends to line it up parallel to the field like a compass. The energy associated with this torque is\n$$ H = -\\vec{\\mu} \\cdot \\vec{B} = -\\gamma \\vec{B} \\cdot \\vec{S}. $$\nTherefore, the Zeeman Hamiltonian is\n$$ \\hat{H}_Z = -\\vec{mu} \\cdot \\vec{B}_0 = \\frac{g\\mu_B}{\\hbar} \\vec{S} \\cdot \\vec{B}_0 = \\frac{g\\mu_B}{\\hbar}B_0 S_z $$\nwhere $S_z = \\frac{\\hbar}{2} \\hat{\\sigma}_z$ and $\\sigma_z$ is the Pauli-$z$ spin matrix. Applying $\\hat{H}_Z$ on an arbitrary spin state $|s, m_s\\rangle$ gives\n$$ \\begin{align*} \\hat{H}_Z |s, m_s\\rangle \u0026amp;= \\frac{g\\mu_B}{\\hbar}B_0 \\cdot S_z |s, m_s\\rangle \\\\ \u0026amp;= \\frac{g\\mu_B}{\\hbar}B_0 \\cdot m_s\\hbar|s, m_s\\rangle \\\\ \u0026amp;= m_s g \\mu_B B_0 |s, m_s\\rangle. \\end{align*} $$\nOrdinarily we use an anisotropic $g$-tensor. Magnetic fields in different directinos act differently on $|s, m_s\\rangle$. So we would replace with a $3 \\times 3$ $g$ tensor,\n$$\\hat{H}_Z = \\mu_B \\vec{S} \\cdot g \\cdot \\vec{B}_0.$$\nThis can be diagonalized along $|s, m_s\\rangle$\u0026rsquo;s principle axis to make things easier.\n$$ g_{\\mathrm{diag}} = \\begin{pmatrix} g_x \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; g_y \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; g_z \\end{pmatrix}. $$\nFor our simulation though, we\u0026rsquo;ll start with $g \\approx 2.0023$. Our Zeeman Hamiltonian is given by\n$$ \\boxed { \\hat{H}_Z |s, m_s\\rangle = m_s g \\mu_B B_0 |s, m_s\\rangle. } $$\nThis term determines how spin states split and align in an external field. It\u0026rsquo;s the dominant term in the Spin Hamiltonian that drives recombination.\n"},{"id":2,"href":"/posts/nasa_intro/","title":"My project at NASA","section":"Writeups","content":" My work revolves around Electrically Detected Magnetic Resonance (EDMR). It\u0026rsquo;s a method to detect small magnetic fields electrically. In principle it\u0026rsquo;s very simple.\nSay we have a semiconductor, like silicon carbide. This semiconductor, made by nature or in a lab, is never perfect. There may exist some missing atoms, or extra atoms, deep in its molecular structure. These defects provide some extra electrons, or extra holes, which can be used for quantum sensing. In EDMR, they are used to measure magnetic fields electrically. I\u0026rsquo;ll now walk through how this is done in silicon carbide (4H-SiC) specifically.\nDefects in Silicon Carbide# Let\u0026rsquo;s look at the molecular structure of 4H-SiC.\nIdeally, it\u0026rsquo;s consistently full of silicon and carbon. However, what if somewhere there\u0026rsquo;s a missing silicon atom (middle of figure)? This is a common defect, known as the Silicon Vacancy. It\u0026rsquo;s a spin $S=3/2$ defect; how we get 3/2 isn\u0026rsquo;t important.\nEnergy Levels# When current flows through a semiconductor, the carrier electrons move through the conduction band, a band of energy a bit higher than where the valence electrons of silicon and carbon rest. The energy level of the defect lies somewhere in between.\nIn 4H-SiC, the conduction band is $\\sim$3.3eV higher than the valence band. If an electron ($S=1/2$) in the conduction band passes over a defect, the defect can trap it at its lower energy state.\nRecombination# Now the carrier electron is at the defect energy level, a bit below the conduction band. When can it travel all the way down to the valence band?\nElectron spin is an angular momentum. If an electron were to travel to the valence band then it would occupy a hole. This final state would have spin $S=0$. By angular momentum conservation, the defect-electron state before must have spin $S=0$ too.\nFor two particles (defect + electron), this is the singlet state, when both spins are antiparallel. A carrier electron can only undergo recombination if it forms a singlet state with the defect. If the carrier electron forms a triplet state, ($S = 1$), it immediately returns back up to the conduction band.\nThis is known as Spin-Dependent Recombination (SDR), illustrated below.\nCurrent# When an electron undergoes recombination, it fully leaves the conduction band. Therefore, current decreases.\nAnd since magnetic fields alter spin alignment (Zeeman precession), they change the rate of recombination, so they change current.\nIf we detect changes in current, we detect changes in the magnetic field. This is EDMR.\nThere are other mechanisms at play besides recombination though. Defects also provide a intermediary path for electrons to \u0026ldquo;hop\u0026rdquo; through to lower energy levels. This also lets them escape the conduction band, changing current. This is known as Spin-Dependent Trap-Assisted Tunneling (SDTAT), and is detectable by EDMR. However, an electron quantum tunneling is rarer than undergoing recombination, so recombination is the primary mechanism for EDMR.\nThe Goal# My work at NASA will be simulating this entire process, as fast as possible. The final simulation will take in all experimental parameters, to be explained later, and spit out an EDMR spectra. This spectra is a plot of magnetic field vs. current.\nI am told the use-case of this simulation will be to develop an automatic GPS aboard aircrafts that uses the Earth\u0026rsquo;s magnetic field. If a pilot\u0026rsquo;s GPS fails, a simulation could continuously predict EDMR spectra based on the surrounding environment. Different locations on Earth have different ambient magnetic fields, so a makeshift GPS is possible. I don\u0026rsquo;t think this idea is necessarily applicable in practice. There are better ways of error-handling a GPS failure. However, it\u0026rsquo;s a fun project.\nIn any case, we may understand spin-physics a bit more. This post was a bit abstracted. For the next few posts, I plan to cover the core physics of spin-dependent recombination and then start writing software to simulate it.\n"},{"id":3,"href":"/resume/","title":"Resume","section":"my undergrad work","content":" Can’t display the PDF. Download.\n"}]